{"name":"Wasabi","tagline":"","body":"# Wasabi\r\n\r\nA simple replication library using *binary* encoding over WebSockets (no\r\nfallbacks). Released under the MIT License.\r\n\r\n    npm install wasabi\r\n\r\nThe main advantages of using Wasabi are:\r\n\r\n - You only need to write single short function per class to start\r\n   replicating\r\n - All data is transferred as binary as opposed to ascii JSON\r\n - Replicated object lifetimes are automatically managed based on a\r\n   \"scope\" callback which may be set for each client (or not at all)\r\n - Remote RPC invocation works almost exactly like local function calls\r\n - Prototypal inheritance of is fully supported out-of-the-box\r\n\r\n# Usage\r\n\r\n## Simple Replication\r\n\r\nSay you have a Player object you use in an existing (client-only) game:\r\n**old player.js**\r\n\r\n    function Player () {\r\n        this.x = Math.floor(Math.random() * 400);\r\n        this.y = Math.floor(Math.random() * 400);\r\n        this.health = 1.0;\r\n    }\r\n\r\nTo start replicating this class with Wasabi, just register it and write a\r\n`serialize` method for it.  Wasabi uses these `serialize` methods to\r\ndescribe the replicated attributes, their types, and the bits required to\r\nencode their maximum value.\r\n\r\n**new player.js**\r\n\r\n    function Player () {\r\n        this.x = Math.floor(Math.random() * 400);\r\n        this.y = Math.floor(Math.random() * 400);\r\n        this.health = 1.0;\r\n    }\r\n    \r\n    // serialize\r\n    Player.prototype.serialize = function (desc) {\r\n        desc.uint('x', 16); // a 16 bit unsigned integer named x\r\n        desc.uint('y', 16); // a 16 bit unsigned integer named y\r\n        desc.float('health', 16); // a normalized 16 bit signed float\r\n    }\r\n\r\nThe `desc` argument which Wasabi passes to `serialize` is a \"description\"\r\nof the object. The actual class of the `desc` object is determined by the\r\nwhether the object is being packed or unpacked. Using this one weird\r\ntrick, you only have to write a single function and Wasabi will figure\r\nout how to take your object in *and* out of the network.\r\n\r\nAt this point you're ready to start replicating:\r\n\r\n**server.js**\r\n\r\n    var Player = require('./player.js')\r\n      , Wasabi = require('wasabi')\r\n      , WebSocket = require('ws')\r\n      ;\r\n    \r\n    Wasabi.addClass(Player);\r\n    \r\n    var webSockServer = new WebSocket.Server({port:1234}, function() {\r\n        setInterval(function() {\r\n            // handle connections\r\n            Wasabi.processConnections();\r\n            \r\n            // simulation update code goes here\r\n            \r\n        }, 50);\r\n    });\r\n  \r\n    webSockServer.on('connection', function(clientSock) {\r\n        // add the new client's connection to the server's Wasabi instance\r\n        Wasabi.addClient(clientSock);\r\n        \r\n        // create the player's game object and add it to Wasabi\r\n        var newPlayer = new Player();\r\n        Wasabi.addObject(newPlayer);\r\n    });\r\n\r\nYou probably want to then read the object from a socket on the client side:\r\n\r\n**client.js**\r\n\r\n    Wasabi.addClass(Player);\r\n    \r\n    var sock = new WebSocket('ws://localhost:1234');             \r\n    Wasabi.addServer(sock);\r\n    \r\n    sock.onopen = function() {\r\n        setInterval(function() {\r\n            // receive network stuff\r\n            Wasabi.processConnections();\r\n            \r\n            // client-side update code goes here\r\n            \r\n        }, 50);\r\n    }\r\n\r\n## Remote Procedure Calls\r\n### Definition\r\n*Defining and invoking RPCs is currently a little wonky. Progress is being made towards more natural invocation and definition conventions, so the following is subject to change.*\r\n\r\nTo define a class RPC, create a method prefixed with \"rpc\" which takes a single `args` argument, which is an Object of named arguments and their values:\r\n\r\n    Player.prototype.rpcYell = function (args) {\r\n        var i;\r\n        for(i = 0; i < args.times; i++) {\r\n            console.log('SPAARTA!');\r\n        }\r\n    }\r\n    \r\nHere's the wonkiness: you have to write an `rpc*Args` for any RPC that takes arguments. This is exactly the same as writing a `serialize` method for replicated classes. For `rpcYell` above, we'll need to write `rpcYellArgs` as follows:\r\n\r\n    Player.prototype.rpcYellArgs = function (desc) {\r\n        desc.uint('times', 8);\r\n    }\r\n    \r\nMake sure that you call `addClass` only **after** defining RPCs, as Wasabi will look for any methods starting with `rpc` and replace them with the actual remote invocation stubs.\r\n\r\n### Invocation\r\nOn the server side we can make a Player \"yell\" on the clients by saying:\r\n\r\n    player.rpcYell({times: 3});\r\n    \r\nSomething to note: you must pass rpcYell an object of named arguments, just as its definition would suggest. If you try to invoke an RPC without the `args` object, e.g. as `player.rpcYell(3)`, Wasabi will throw an error.\r\n\r\n# Benchmarks\r\nWasabi has cpu and network usage benchmark which can be run via `sudo jake bench` (you need sudo because it measures network usage with pcap... patches welcome). Here is the performance of Wasabi v0.1.3 on a 2.8Ghz AMD chip:\r\n\r\n    One connection, 1000 objects x 148 ops/sec ±0.83% (86 runs sampled)\r\n    Ten connections, 100 objects x 144 ops/sec ±0.93% (84 runs sampled)\r\n    100 connections, ten objects x 109 ops/sec ±1.06% (82 runs sampled)\r\n    Ten connections, ten objects x 1,165 ops/sec ±0.82% (98 runs sampled)\r\n    \r\n    Start of TCP session between 127.0.0.1:47099 and 127.0.0.1:31337\r\n    1 clients with 100 objects for 1000 iterations\r\n    End of TCP session between 127.0.0.1:47099 and 127.0.0.1:31337\r\n    client -> server: 9.15kB (61.42kB with transport)\r\n    0.92kB/s at 15hz\r\n    server -> client: 820.59kB (872.85kB with transport)\r\n    13.09kB/s at 15hz\r\n\r\n# Contact\r\nIf you have bug reports, feature requests, questions, or pull requests, drop by the [github repo](https://github.com/kaen/wasabi). If you have lavish praise or eloquent maledictions, email me at [bkconrad@gmail.com](mailto:bkconrad@gmail.com).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}