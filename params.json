{"name":"Wasabi","tagline":"Spicy, low-calorie object replication over binary WebSockets.","body":"# Wasabi\r\n\r\nA simple then powerful replication library using binary encoding over WebSockets. Released under the MIT License.\r\n\r\n    npm install wasabi\r\n\r\nThe main advantages of using Wasabi are:\r\n\r\n - All data is tightly packed as binary rather than JSON, with user-specified\r\n   precision.\r\n - You only need to write a single short function per class to start replicating\r\n - Replicated object lifetimes can be managed based on a \"scope\" callback which\r\n   may be set for each client (or not at all)\r\n - Remote RPC invocation works exactly like local function calls\r\n - Prototypal inheritance of is fully supported out-of-the-box\r\n - You can get started without much boilerplate, then define additional\r\n   functions to increase performance when you become production-ready\r\n\r\n# Usage\r\n\r\nFor further reading, make sure to look at the [API Docs on\r\nGitHub](http://kaen.github.io/wasabi/doc/) or build your own locally with `jake\r\ndoc`.\r\n\r\n## Simple Replication\r\n\r\nSay you have a Player object you use in an existing (client-only) game:\r\n**old player.js**\r\n\r\n    function Player () {\r\n        this.x = Math.floor(Math.random() * 400);\r\n        this.y = Math.floor(Math.random() * 400);\r\n        this.health = 1.0;\r\n    }\r\n\r\nTo start replicating this class with Wasabi, just register it and write a\r\n`serialize` method for it.  Wasabi uses these `serialize` methods to\r\ndescribe the replicated attributes, their types, and the bits required to\r\nencode their maximum value.\r\n\r\n**new player.js**\r\n\r\n    function Player () {\r\n        this.x = Math.floor(Math.random() * 400);\r\n        this.y = Math.floor(Math.random() * 400);\r\n        this.health = 1.0;\r\n    }\r\n    \r\n    // serialize\r\n    Player.prototype.serialize = function (desc) {\r\n        desc.uint('x', 16); // a 16 bit unsigned integer named x\r\n        desc.uint('y', 16); // a 16 bit unsigned integer named y\r\n        desc.float('health', 16); // a normalized 16 bit signed float\r\n    }\r\n\r\nThe `desc` argument which Wasabi passes to `serialize` is a \"description\" of the\r\nobject. The actual class of the `desc` object is determined by whether the\r\nobject is being packed or unpacked. Using this one weird trick, you only have to\r\nwrite a single function and Wasabi will figure out how to take your object in\r\n*and* out of the network.\r\n\r\nAt this point you're ready to start replicating:\r\n\r\n**server.js**\r\n\r\n    var Player = require('./player.js')\r\n      , Wasabi = require('wasabi')\r\n      , WebSocket = require('ws')\r\n      ;\r\n    \r\n    Wasabi.addClass(Player);\r\n    \r\n    var webSockServer = new WebSocket.Server({port:1234}, function() {\r\n        setInterval(function() {\r\n            // handle connections\r\n            Wasabi.processConnections();\r\n            \r\n            // simulation update code goes here\r\n            \r\n        }, 50);\r\n    });\r\n  \r\n    webSockServer.on('connection', function(clientSock) {\r\n        // add the new client's connection to the server's Wasabi instance\r\n        Wasabi.addClient(clientSock);\r\n        \r\n        // create the player's game object and add it to Wasabi\r\n        var newPlayer = new Player();\r\n        Wasabi.addObject(newPlayer);\r\n    });\r\n\r\nYou probably want to then read the object from a socket on the client side:\r\n\r\n**client.js**\r\n\r\n    Wasabi.addClass(Player);\r\n    \r\n    var sock = new WebSocket('ws://localhost:1234');             \r\n    Wasabi.addServer(sock);\r\n    \r\n    sock.onopen = function() {\r\n        setInterval(function() {\r\n            // receive network stuff\r\n            Wasabi.processConnections();\r\n            \r\n            // client-side update code goes here\r\n            \r\n        }, 50);\r\n    }\r\n\r\n## Remote Procedure Calls\r\n### Definition\r\nTo define a class RPC, create a method prefixed with \"rpc\":\r\n\r\n    Player.prototype.rpcYell = function (times) {\r\n        var i;\r\n        for(i = 0; i < times; i++) {\r\n            console.log('SPAARTA!');\r\n        }\r\n    }\r\n    \r\nMake sure that you call `addClass` only **after** defining RPCs, as Wasabi will\r\nlook for any methods starting with `rpc` and replace them with the actual remote\r\ninvocation stubs.\r\n\r\n### Invocation\r\nFrom the server side we can make a Player \"yell\" on the clients by saying:\r\n\r\n    player.rpcYell(3);\r\n\r\n### Performance Enhancement\r\nIn order to allow rapid prototyping, Wasabi will infer the types of the\r\narguments (float, uint, etc.) upon invocation by default. There is significant\r\nCPU and network overhead involved in doing this, so it is highly recommended\r\nthat production code includes \"args\" functions for each RPC. The args function\r\nis written like the serialize function for an object, but is applied to the\r\narguments on the RPC. The benefit of writing these functions is that Wasabi\r\ndoesn't have to detect the types of the arguments, and also does not have to\r\nencode type information over the network.\r\n\r\nThe args function for `rpcYell` above would look like:\r\n\r\n    Player.prototype.rpcYellArgs = function (desc) {\r\n        desc.uint('times', 8); // An 8-bit unsigned integer\r\n    }\r\n\r\n# Benchmarks\r\nWasabi has cpu and network usage benchmark which can be run via `sudo jake\r\nbench` (you need sudo because it measures network usage with pcap... patches\r\nwelcome). Here is the performance of Wasabi v0.1.3 on a 2.8Ghz CPU:\r\n\r\n    One connection, 1000 objects x 148 ops/sec ±0.83% (86 runs sampled)\r\n    Ten connections, 100 objects x 144 ops/sec ±0.93% (84 runs sampled)\r\n    100 connections, ten objects x 109 ops/sec ±1.06% (82 runs sampled)\r\n    Ten connections, ten objects x 1,165 ops/sec ±0.82% (98 runs sampled)\r\n    \r\n    Start of TCP session between 127.0.0.1:47099 and 127.0.0.1:31337\r\n    1 clients with 100 objects for 1000 iterations\r\n    End of TCP session between 127.0.0.1:47099 and 127.0.0.1:31337\r\n    client -> server: 9.15kB (61.42kB with transport)\r\n    0.92kB/s at 15hz\r\n    server -> client: 820.59kB (872.85kB with transport)\r\n    13.09kB/s at 15hz\r\n\r\n# Contact\r\nIf you have bug reports, feature requests, questions, or pull requests, drop by\r\nthe [github repo](https://github.com/kaen/wasabi). If you have lavish praise or\r\neloquent maledictions, email me at [bkconrad@gmail.com](mailto:bkconrad@gmail.com).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}